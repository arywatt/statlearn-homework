---
title: "Statlearn - homework II"
output:
  word_document: default
  html_document: default
  pdf_document: default
---

# Part I -  Song genre classification 


## Installing and importing libraries

```{r}

# this part is to be executed only once to install libraries we need 
# i kindly suggest you run this on windows OS
# But if you feel like  solving R dependencies hell on linux... give it a try .
# about macOS , don't really know
# 
# 
# install.packages('signal')
# install.packages('audio')
# install.packages('wrassp')
# install.packages('warbleR')
# install.packages('tuneR')
# install.packages('audiolyzR')


```


```{r}
# then we import all libraries needed here
suppressMessages(require(signal, quietly = T))
library(signal)

suppressMessages(require(audio, quietly = T)) 
library(audio)

suppressMessages(require(wrassp,  quietly = T))
library(wrassp)


library(warbleR)
library(tuneR)
library(audiolyzR)

```

## Reading and describing Data
```{r}
# My path to the data 
auPath <- "data_example"
labelsFile <- paste0(auPath,'/labels.txt')
labelsFile

# List the .au files
auFiles <- list.files(auPath, pattern=glob2rx('*.au'), full.names=TRUE)
auFiles

# Number of files 
N <- length(auFiles)

```

we have a total of {N} songs in our dataset .


```{r}
## Let's try to get the files in order 
ord = c(1:N)
ordFileList = paste0(rep(paste0(auPath,'/f')),paste0(ord,rep('.au',N)))
ordFileList

# let's get also labels for each files
labels <- read.table(file=labelsFile, header=TRUE, sep=" ",col.names  = c('id','type'))
 
labels
?read.csv

```

```{r}

# Load an audio file, e.g. the first one in the list above
x <- read.AsspDataObj(ordFileList[1])
str(attributes(x))
 
#Then we set a fixed samples length for all files
# as the minimum lenght of all of them 
fixedLength = 22050 * 30 # default length


for (i in 1:N) {
  x <- read.AsspDataObj(auFiles[i])
  min = attributes(x)$endRecord   # the samples length of the current file
  fixedLength <- ifelse(fixedLength<=min, fixedLength, min) # we take the minimum
}
```

We can see from the output that The records were made at a sample rate of 22050hz 
for a duration of 30 seconds and therefore  contains around 22050 * 30 = 661500 samples

Now lets' plot rthe first file samples to geta general idea


```{r}

# We 
# (only plot every 10th element to accelerate plotting)

x = read.AsspDataObj(ordFileList[1])
x

ith = 22050 /5 # ith element to plot . basically we are plotting elements each 0.2s

x_axe = seq(0,numRecs.AsspDataObj(x) - 1, ith) / rate.AsspDataObj(x)

y_axe =  x$audio[c(TRUE, rep(FALSE,ith-1))]

plot(x_axe,
     y_axe,
     type='l',
     xlab='time (s)',
     ylab='Audio samples')

```

## Basic useful functions

```{r}

# Transform


# x : array to transform 
# rate : the sample rate of x 
# bit : 
# reduceRate : wether reduce the sample rate or not 
# newRate  # if down Sample is TRUE, new sample rate to use 
transformToWave <- function(x, rate, bit = 16,reduceRate = FALSE, newRate = 11025 ){
  xwv <- Wave( as.numeric(x), rate = rate, bit = bit)
  transformedWave <- ifelse(reduceRate,  downsample(xwv, samp.rate = newRate),xwv)
  return( xwv)
}
```

```{r}

# ?powspec

# x : audio samples array 
# rate : samples rate 
# The output is a matrix, where each column represents a power spectrum 
# for a given time frame and each row represents a frequency.
powerSpectrum <- function(x , rate ){
  
  out = powspec( as.numeric(x), rate)
  return(out)

}
```


```{r}

# Spetral info ------------------------------------------------------------

# calculate the fundamental frequency contour
# name : name of the file input
spectralInfo <- function(name){
   f0vals = ksvF0("data_example/f1.au", toFile=F)
   return(fOvals)
}


```

```{r}
# STFT --------------------------------------------------------------------

# get the spectogram of a wave 
# x : wave array 
# winsize : Fourier transform window size
# fs : rate 
# winshape : fourier transform window shape
# overlap : overlap with previous window, defaults to half the window length.
getSpecgram <- function (x, winsize, fs ,winshape ,overlap){
  sp  <- specgram(x, n = winsize, Fs = fs, window = winsize, overlap = overlap)
  return(sp)
  
}


```

```{r}

# Energy bannds  ----------------------------------------------------------------

# x : audio spectogram
# winsize : Fourier transform window size
# fs : rate 
# nb : number of bands to select
# lowB :
# eps : default minimum energy value 



energyBands <- function(x,fs,nb, lowB,eps,winsize){
ntm      <- ncol(x$S)  # number of (overlapping) time segments
fco    <- round( c(0, lowB*(fs/2/lowB)^((0:(nb-1))/(nb-1)))/fs*winsize )
energy <- matrix(0, nb, ntm)
for (tm in 1:ntm){
  for (i in 1:nb){
    lower_bound <- 1 + fco[i]
    upper_bound <- min( c( 1 + fco[i + 1], nrow(x$S) ) )
    energy[i, tm] <- sum( abs(x$S[ lower_bound:upper_bound, tm ])^2 )
  }
}
energy[energy < eps] <- eps
energy = 10*log10(energy)

return(energy)
  
  
}


```

## Creating the dataset 

We basically loop on on audio files, and compute some features using functions defined above .

```{r}


# first we define the general parameters

rate = 22050
newrate = 11050
reduceRate = FALSE


# STFT
winsize  <- 2048
nfft     <- 2048
hopsize  <- 512
overlap <- winsize - hopsize

# Frequency bands selection
nb   <- 2^3
lowB <- 100
eps  <- .Machine$double.eps
# Number of seconds of the analyzed window
corrtime     <- 15

# the file list to use is our Ordered file list 

for( file in ordFileList){
  
  # we only take the fixed length sample  to make equal for all files 
  x = read.AsspDataObj(file)[1:fixedLength]
  xWave = transformToWave(x,rate)
  xPoweSpec = powerSpectrum(x,rate)
  xSpecgram = getSpecgram(x,fs = fs,winsize = winsize,winshape = winshape,overlap = overlap)
  xSpectralInfo = spectralInfo(file)
  
}


```





## Features Extractions 
## Models to apply 
### List of models to use and reasons (limit to models seen in class)
### Models Implementation
## classification
### Evaluate classification performance for each model
### Chose the best model 
### Determine each feature contribution to model
### Maintain only the most important ones
### Final classification
## Map


# Part II -  Theory
