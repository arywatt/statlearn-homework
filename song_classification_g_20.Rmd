---
title: "Statlearn - homework II"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

# Part I -  Song genre classification 


## Installing and importing libraries

```{r}

# this part is to be executed only once to install libraries we need 
# i kindly suggest you run this on windows OS
# But if you feel like  solving R dependencies hell on linux... give it a try .
# about macOS , don't really know
# 
# 
# install.packages('signal')
# install.packages('audio')
# install.packages('wrassp')
# install.packages('warbleR')
# install.packages('tuneR')
# install.packages('audiolyzR')




```


```{r ,include=FALSE}
# then we import all libraries needed here
suppressMessages(require(signal, quietly = T))
library(signal)

suppressMessages(require(audio, quietly = T)) 
library(audio)

suppressMessages(require(wrassp,  quietly = T))
library(wrassp)

library(soundgen)
library(warbleR)
library(tuneR)
library(audiolyzR)


```

## Reading and describing Data
```{r}
# My path to the data 
auPath <- "hw_data"
labelsFile <- paste0(auPath,'/labels.txt')
labelsFile

# List the .au files
auFiles <- list.files(auPath, pattern=glob2rx('*.au'), full.names=TRUE)
auFiles

# Number of files 
N <- length(auFiles)

```

we have a total of {N} songs in our dataset .


```{r}
## Let's try to get the files in order 
ord = c(1:N)
ordFileList = paste0(rep(paste0(auPath,'/f')),paste0(ord,rep('.au',N)))
#ordFileList

# let's get also labels for each files
labels <- read.table(file=labelsFile, header=TRUE, sep=" ",col.names  = c('id','genre'))
 
labels = labels['genre']
dim(labels)
str(labels)
barplot(table(labels$genre))


```

```{r}

# Load an audio file, e.g. the first one in the list above
x <- read.AsspDataObj(ordFileList[1])
str(attributes(x))
 
#Then we set a fixed samples length for all files
# as the minimum lenght of all of them 
fixedLength = 22050 * 30 # default length


for (i in 1:N) {
  x <- read.AsspDataObj(auFiles[i])
  min = attributes(x)$endRecord   # the samples length of the current file
  fixedLength <- ifelse(fixedLength<=min, fixedLength, min) # we take the minimum
}

fixedLength
```

We can see from the output that The records were made at a sample rate of 22050hz 
for a duration of 30 seconds and therefore  contains around 22050 * 30 = 661500 samples

Now lets' plot the first file samples to get a general idea


```{r}

# We 
# (only plot every 10th element to accelerate plotting)

x = read.AsspDataObj(ordFileList[1])
x

ith = 22050 /5 # ith element to plot . basically we are plotting elements each 0.2s

x_axe = seq(0,numRecs.AsspDataObj(x) - 1, ith) / rate.AsspDataObj(x)

y_axe =  x$audio[c(TRUE, rep(FALSE,ith-1))]

plot(x_axe,
     y_axe,
     type='l',
     xlab='time (s)',
     ylab='Audio samples')

```

## Features Extractions 

### Features to extract

#### Zero crossing rate 

The zero-crossing rate is the rate of sign-changes along a signal, i.e., the rate at which the signal changes from positive to zero to negative or from negative to zero to positive.[1] This feature has been used heavily in both speech recognition and music information retrieval, being a key feature to classify percussive sounds.


####  Spectral Centroid and others statistics 

the spectral prperties are a set of statistics computed on the spectrum of an audio signal, sucha as 
- Spectral Centroid ( most important one)
- Spectral mean or median 
- spectral quartiles , skewness and kurtosis

The spectral centroid is a measure used in digital signal processing to characterise a spectrum. It indicates where the center of mass of the spectrum is located. Perceptually, it has a robust connection with the impression of brightness of a sound.
We basically loop on on audio files, and compute some features using functions defined above .

It is calculated as the weighted mean of the frequencies present in the signal, determined using a Fourier transform, with their magnitudes as the weights



#### Mel Frequency Cepstral Coefficients
 Mel Frequency Cepstral Coefficients (MFCC) for an object of class Wave. In speech recognition MFCCs are used to extract the stimulus of the vocal tract from speech
 
 

####  Pitch and loudness 

Pitch is a perceptual property of sounds that allows their ordering on a frequency-related scale, or more commonly, pitch is the quality that makes it possible to judge sounds as "higher" and "lower" in the sense associated with musical melodies. Pitch can be determined only in sounds that have a frequency that is clear and stable enough to distinguish from noise. Pitch is a major auditory attribute of musical tones, along with duration, loudness, and timbre.


With the soundgen library we can analyse the sound to retrieve some feature lke ,
the average pitch, the loudness,the peak frequncies, whether sound contains voice or not , the harmonics. All thoses values will hell differentiate genre of music.
Below an Exemple of  plot showing a classic music, a country music

![Country music visualization](country.png)






![Classic music visualization](classic.png)


### Implementation with R

In R we used principally package 
 - Seawave
 - SoundGen
 - TuneR
 
#### Convert audio data to wave 

```{r}

# Transform


# x : array to transform 
# rate : the sample rate of x 
# bit : 
# reduceRate : wether reduce the sample rate or not 
# newRate  # if down Sample is TRUE, new sample rate to use 
transformToWave <- function(x, rate, bit = 16,reduceRate = FALSE, newRate = 11025 ){
  xwv = Wave( as.numeric(x), samp.rate = rate, bit = bit)
  if(reduceRate){
    xwv = downsample(xwv, samp.rate = newRate)
  }
  #transformedWave <- ifelse(reduceRate,  downsample(xwv, samp.rate = newRate),xwv)
  return( xwv)
}
```

#### Spectrum analysis , power spectrum and energy band 
```{r, include=FALSE}


#Frequency spectrum of a time wave

# x	: an R wave object.

# fs :	sampling frequency of wave (in Hz). Does not need to be specified if embedded in wave.

# wl	: if at is not null, length of the window for the analysis (by default = 512).

# wn	 : window name, see ftwindow (by default "hanning").

# fftw : if TRUE calls the function FFT of the library fftw for faster computation. See Notes of the function spectro.

# norm	#if TRUE the spectrum is normalised by its maximum.

getSpec <- function (x, winsize, fs ){
  sp  <- meanspec(x,  fs = fs, wl = winsize, fftw = TRUE,norm  =TRUE,plot = FALSE)
  return(sp)
}

#-----------------------------------------------------------------------------------
# To get spectral properties 

# spec	: a data set resulting of a spectral analysis obtained with spec or meanspec (not in dB).

# f	 :sampling frequency of spec (in Hz).

# str	:logical, if TRUE returns the results in a structured table.

# flim	:a vector of length 2 to specifgy the frequency limits of the analysis (in kHz)

# mel	#a logical, if TRUE the (htk-)mel scale is used.

GetSpecProps <- function(spec, fs){
  specProps = specprop(spec, f= fs, mel = TRUE)
  return(specProps)
}

#---------------------------------------------------------------

# compute the zero crossing rate

# x :  R wave object 	


#f :sampling frequency of wave (in Hz). Does not need to be specified if embedded in wave.

#wl: length of the window for the analysis (even number of points, by default = 512). If NULL the zero-crossing rate is computed of the complete signal.

#overlap	: overlap between two successive analysis windows (in %) if wl is not NULL.
  zeroCrossingRate <- function (x , fs, wl , overlap ){
    cr = zcr(x,f= fs, wl = wl, ovlp = overlap,plot=FALSE)
    str(cr)
    return(cr)
    
  }

# Computation of MFCCs (Mel Frequency Cepstral Coefficients) for a Wave object

# x :  Object of class Wave.

getMfccs <- function(x, fs){
  mfccs = melfcc(x, 
                 sr=fs,
                 #sumpower = FALSE,
                 numcep = 5
                 #wintime = 0.025,
                 #spec_out = FALSE
                 )
  return(mfccs)
}


# Energy bands  ----------------------------------------------------------------

# x : audio spectogram
# winsize : Fourier transform window size
# fs : rate 
# nb : number of bands to select
# lowB :
# eps : default minimum energy value 



energyBands <- function(x,fs,nb, lowB,eps,winsize){
ntm      <- ncol(x$S)  # number of (overlapping) time segments
fco    <- round( c(0, lowB*(fs/2/lowB)^((0:(nb-1))/(nb-1)))/fs*winsize )
energy <- matrix(0, nb, ntm)
for (tm in 1:ntm){
  for (i in 1:nb){
    lower_bound <- 1 + fco[i]
    upper_bound <- min( c( 1 + fco[i + 1], nrow(x$S) ) )
    energy[i, tm] <- sum( abs(x$S[ lower_bound:upper_bound, tm ])^2 )
  }
}
energy[energy < eps] <- eps
energy = 10*log10(energy)

return(dim(energy))
  
  
}



``` 




### Dataset Creation 

Basically we loop over the audio file, extracting all features and saving in in text file 
```{r}


# first we define the general parameters

rate = 22050
newrate = 11050
reduceRate = FALSE
if(reduceRate) rate = newrate


# STFT
winsize  <- 2048 
nfft     <- 2048 
hopsize  <- 1024
overlap <- winsize - hopsize
#scale = 40000

# Frequency bands selection
nb   <- 2^3
lowB <- 100
eps  <- .Machine$double.eps
# Number of seconds of the analyzed window
corrtime     <- 15

```


```{r, include=FALSE}

# the file list to use is our Ordered file list 
featurelist = list()
features_names = c()

for( j in 1:N){

  file = ordFileList[j]
  features = c()
  
  
  
  # we only take the fixed length sample  to make equal for all files 
  x = read.AsspDataObj(file)$audio[1:fixedLength]
  xwave = transformToWave(x,rate,reduceRate = TRUE)
 
  #xPoweSpec = powerSpectrum(x,rate)
  #print(xPoweSpec)
  
  
  #xSpecgram = getSpecgram(x,fs = rate,winsize = winsize,overlap = overlap)
  #print(xSpecgram)
  
 
  # xSpectralInfo = spectralInfo(file)
  # print(xSpectralInfo)
  
  
  spec = getSpec(xwave , rate ,winsize = winsize)
  specprops = GetSpecProps(spec,rate)
  #str(specprops)

  len = length(specprops)-1
  for (i in 1:len){
    features = append(features,specprops[[i]])
  }
  if(j==1) features_names = append(features_names,
                                   paste0('spec_',names(specprops)[1:len])
                                   )


   # get ZeoCrossing Rate
   cr = zeroCrossingRate(xwave,rate,wl=NULL,overlap = noverlap)
   features = append(features,cr)
   if(j==1) features_names = append(features_names,'zcr')
  
    
    # Get MFCCs
    mfccs = getMfccs(xwave,rate)
    cm = colMeans(mfccs,na.rm = TRUE)

    features = append(features,cm)
    if(j==1) features_names = append(features_names, 
                                     c('mfcc1','mfcc2','mfcc3','mfcc4','mfcc5')
                                     )
    
    
    
    
    #-----------------------------------------------------------------------------

  featurelist[j] = c(list(features))
   
  
}

str(featurelist)
str(features_names)



```


```{r}

data1 = as.data.frame(matrix(unlist(featurelist),   
                            nrow=length(unlist(featurelist[2]))
                            )
                     )
#
features_names = c(features_names)
row.names(data1) = features_names
data1= t(data1)
#write.csv(data1,file = 'data1.csv')

```


```{r}
toget = c('ampl','dom','harmonics','loudness','peakFreq',
          'peakFreqCut','pitch','pitchSpec' )
toget_means = paste0(toget,'_mean')

toget_sds = paste0(toget,'_sd')

toget_maxs = paste0(toget,'_max')
 
toget_final = c(toget_means,toget_sds)

featurelist2 = list() 

for (j in 1:N){
# retrieve sound file
file = ordFileList[j]
x = read.AsspDataObj(file)$audio[1:fixedLength]
xwave = transformToWave(x,rate,reduceRate = TRUE)

  

## Perform analysis on sound file
df = analyze(xwave@left
             ,samplingRate = rate,
             summary = TRUE,
             plot = FALSE,
             windowLength = winsize
             
             
             )


# retrieve important features  
toget_values = df[toget_final]

features = c()
 for (i in 1:length(toget_final)){
    features = append(features,toget_values[[i]])
 }


featurelist2[j] = c(list(features))
print(j)

}

featurelist2


```


```{r}

data2 = as.data.frame(matrix(unlist(featurelist2),   
                            nrow=length(unlist(featurelist2[1]))
                            )
                     )
#
features_names2 = c(toget_final)
row.names(data2) = features_names2
data2= t(data2)
#write.csv(data2,file = 'data2.csv')

str(data2)
summary(data2)


```


We save the dataset  to a file

```{r}

# data = cbind(data1,data2)
# write.csv(data2,file = 'data.csv')

```

```{r}
data = read.csv('data.csv',header = TRUE,sep = ',')[-1]
str(data)
class(data)
summary(data)
row.names(data) = NULL
length(data$ampl_mean)
length(labels$genre)
which(is.na(data))

```





## Models to apply 
### List of models to use and reasons (limit to models seen in class)
### Models Implementation
## Support Vector Machine


```{r}

library("e1071")


x <- data
y <- as.factor(labels$genre)
dataset <- data.frame(data, labels$genre)

  
kernels <- list("linear","polynomial", "sigmoid","radial basis")
Cs <- list(0.001, 0.01, 0.1, 1, 10)
gammas <- list(0.001, 0.01, 0.1, 1)


svmfit <- svm(y~., data=dataset, kernel = "linear", cost=Cs)
svmfit


print(svmfit)
plot(svmfit,dataset)




make.grid = function(x, n =75) {
  grange = apply(x, 2, range)
  x1 = seq(from = grange[1,1], to = grange[2,1], length = n)
  x2 = seq(from = grange[1,2], to = grange[2,2], length = n)
  expand.grid(X1 = x1, X2 = x2)
}

xgrid = make.grid(x)

pred <- predict(svmfit, x)
res <- pred-datappr[,y]


plot(xgrid, col = c("red","blue")[as.numeric(pred)], pch = 20, cex = .2)
points(x, col = y + 3, pch = 19)
points(x[svmfit$index,], pch = 5, cex = 2)

```

## classification
### Classification performance for each model
### Chose the best model 
### Determine each feature contribution to model
### Maintain only the most important ones
### Final classification
## Map


# Part II -  Theory
